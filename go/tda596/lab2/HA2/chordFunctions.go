package main

import (
	"crypto/sha1"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"math/big"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

const (
	ENCRYPTED_RESOURCES_FOLDER = "./resources"
	FILE_PRIVILEGES            = 0o600
	DIR_PRIVILEGES             = 0o700
)

type Key string

type NodeAddress string

type NodeDetails struct {
	OwnIp      string
	OwnPort    int
	SecurePort int
	Id         big.Int
}

type Node struct {
	Info            NodeDetails
	FingerTable     []NodeDetails
	FingerTableSize int
	Predecessor     *NodeDetails
	Successors      []NodeDetails
	SuccessorsSize  int
	NextFinger      int
}

var once sync.Once
var nodeInstance Node

func InitializeNode(ownIp string, ownPort, securePort, fingerTableCount, successorsCount int, additionalId *big.Int) error {
	if fingerTableCount < 1 || successorsCount < 1 {
		return errors.New("sizes need to be at least 1")
	}
	once.Do(func() {
		var address = NodeAddress(ownIp) + ":" + NodeAddress(fmt.Sprintf("%v", ownPort))
		var Details NodeDetails
		if additionalId == nil {
			Details = NodeDetails{
				OwnIp:      ownIp,
				OwnPort:    ownPort,
				SecurePort: securePort,
				Id:         *GenerateHash(string(address)),
			}
		} else {
			Details = NodeDetails{
				OwnIp:      ownIp,
				OwnPort:    ownPort,
				SecurePort: securePort,
				Id:         *additionalId,
			}
		}
		nodeInstance = Node{
			Info:            Details,
			FingerTable:     []NodeDetails{},
			Predecessor:     nil,
			FingerTableSize: fingerTableCount,
			Successors:      []NodeDetails{},
			SuccessorsSize:  successorsCount,
			NextFinger:      -1,
		}
	})
	return nil
}

func FetchChordAddress(node NodeDetails) NodeAddress {
	return NodeAddress(fmt.Sprintf("%v:%v", node.OwnIp, node.OwnPort))
}

func FetchSshAddress(node NodeDetails) string {
	return fmt.Sprintf("%v:%v", node.OwnIp, node.SecurePort)
}

// Increments the value mod th efinger table size
func IncrementFollowFinger() int {
	nodeInstance.NextFinger = (nodeInstance.NextFinger + 1) % nodeInstance.FingerTableSize
	return nodeInstance.NextFinger
}

// Update new immediate successor
func UpdateSuccessor(successor NodeDetails) {
	nodeInstance.Successors = []NodeDetails{successor}
}

// New finger table is created with successor as the first entry.
func UpdateFingerTable(successor NodeDetails) {
	nodeInstance.FingerTable = []NodeDetails{successor}
}

func SuccesorsItself(successors []NodeDetails) int {
	for index, item := range successors {
		if item.Id.Cmp(&nodeInstance.Info.Id) == 0 {
			return index
		}
	}
	return -1
}

// The list of the successor's successors is appended to the node's list of successors.
// In order to make the new successor list as long as possible, entries will be removed.
func AddSuccessors(successors []NodeDetails) {
	ElementsCount := nodeInstance.SuccessorsSize - 1
	var addEelements []NodeDetails
	// If the successors array is not long enough to accommodate the additional entries, the slicing would result in a kernel panic.
	if len(successors) > ElementsCount {
		addEelements = successors[:ElementsCount]
	} else {
		addEelements = successors
	}
	index := SuccesorsItself(addEelements)
	if index != -1 {
		addEelements = addEelements[:index]
	}
	nodeInstance.Successors = append(nodeInstance.Successors, addEelements...)
}

// current successor is Returned
func Successor() NodeDetails {
	return nodeInstance.Successors[0]
}

func SetPredecessor(predecessor *NodeDetails) {
	nodeInstance.Predecessor = predecessor
}

func Get() Node {
	return nodeInstance
}

// Provides the file's node's identifier, IP address, and port.
// This node will be the successor the key generated by the filename
func Lookup(fileKey big.Int) (*NodeDetails, error) {
	node := Get()
	foundNode, err := FindNode(fileKey, node.Info, 32)
	if err != nil {
		return nil, err
	}
	return foundNode, nil
}

// lookup function is called to find the node and store file on
// File is uploaded
func StoreFile(fileLoc string, ssh bool, encrypt bool) (*NodeDetails, *big.Int, error) {
	Loc := strings.Split(fileLoc, "/")
	fileName := Loc[len(Loc)-1]
	fileIdentifier := GenerateHash(fileName)
	node, err := Lookup(*fileIdentifier)
	if err != nil {
		return nil, nil, err
	}
	data, err := FileRead(fileLoc)
	if err != nil {
		return nil, nil, err
	}
	if encrypt {
		cipherData, err := EncryptData(data)
		if err != nil {
			return nil, nil, err
		}
		data = cipherData
	}
	log.Printf("Attempting to store file at %v", *node)
	if ssh {
		fileName := fileIdentifier.String()
		err3 := TransmitFile(FetchSshAddress(*node), fileName, data)
		if err3 != nil {
			return nil, nil, err3
		}
	} else {
		err := SaveClientFile(FetchChordAddress(*node), *fileIdentifier, data)
		if err != nil {
			return nil, nil, err
		}
	}

	return node, fileIdentifier, nil
}

func FetchNodeState(node NodeDetails, collectionItem bool, index int, idealIdentifier *big.Int) (*string, error) {
	NodeDetails := fmt.Sprintf("Identifier: %v address: %v:%v SecurePort: %v", node.Id.String(), node.OwnIp, node.OwnPort, node.SecurePort)
	if collectionItem {
		NodeDetails += fmt.Sprintf("\nIndex: %v\nIdeal Identifier: %v", index, idealIdentifier)
	}
	NodeDetails += "\n"
	return &NodeDetails, nil
}

type CalculateIdealIdentifier func(int) big.Int

func FetchNodeArrayState(nodes []NodeDetails, calculateIdealIdentifier CalculateIdealIdentifier) (*string, error) {
	status := new(string)
	for position, object := range nodes {
		idealIdentifier := calculateIdealIdentifier(position)
		info, err := FetchNodeState(object, true, position, &idealIdentifier)
		if err != nil {
			return nil, err
		}
		*status += *info + "\n\n"
	}
	return status, nil
}

// Obtains the node's current status
// Staus contains: identifier, IP address and port,
// for each node in the successor list, as well as the finger table and itself.
func FetchState() (*string, error) {
	node := Get()
	status, err := FetchNodeState(node.Info, false, -1, nil)
	if err != nil {
		return nil, err
	}
	*status += "Predecessor: "
	if node.Predecessor == nil {
		*status += "None \n"
	} else {
		*status += node.Predecessor.Id.String()
	}

	*status += "\n\nSuccessors:\n"

	successorStatus, err := FetchNodeArrayState(node.Successors, func(i int) big.Int { return *new(big.Int).Add(big.NewInt(int64(i+1)), &node.Info.Id) })
	if err != nil {
		return nil, err
	}
	if successorStatus == nil {
		*status += "No successors\n"
	} else {
		*status += *successorStatus
	}

	*status += "\nFinger table:\n"

	fingerTableStatus, err := FetchNodeArrayState(node.FingerTable, func(i int) big.Int { return *Jump(node.Info.Id, i) })
	if err != nil {
		return nil, err
	}
	if fingerTableStatus == nil {
		*status += "No finger table entries\n"
	} else {
		*status += *fingerTableStatus
	}
	return status, nil
}

func SearchSuccessor(id big.Int) (bool, NodeDetails) {
	node := Get()
	if WithIn(&node.Info.Id, &id, &node.Successors[0].Id, true) {
		log.Printf("Successor search Id: %v, result: %v, %v", id, true, node.Successors[0])
		return true, node.Successors[0]
	}
	nodeNearest := NearestPrecedingNode(id)
	log.Printf("Successor search Id: %v, result: %v, %v", id, false, nodeNearest)
	return false, nodeNearest
}

func FindNode(id big.Int, start NodeDetails, Steps int) (*NodeDetails, error) {
	identified := false
	successorNode := start
	for i := 0; i < Steps; i++ {
		var res, err = RpcSearchSuccessor(FetchChordAddress(successorNode), &id)
		if err != nil {
			return nil, err
		}
		identified = res.Found
		if identified {
			return &res.Node, nil
		}
		successorNode = res.Node
	}
	return nil, errors.New("successor not found")
}

func FindNearPrecedingCandidate(n Node, table []NodeDetails, id big.Int) *NodeDetails {
	for i := len(table) - 1; i >= 0; i-- {
		if WithIn(&n.Info.Id, &table[i].Id, &id, false) {
			return &table[i]
		}
	}
	return nil
}

func NearestPrecedingNode(id big.Int) NodeDetails {
	node := Get()
	var candidate *NodeDetails = FindNearPrecedingCandidate(node, node.FingerTable, id)
	if c := FindNearPrecedingCandidate(node, node.Successors, id); candidate == nil || (c != nil &&
		WithIn(&id, &c.Id, &candidate.Id, false)) {
		candidate = c
	}
	if candidate != nil {
		log.Printf("Near preceding node id: %v, result: %v\n", id, *candidate)
		return *candidate
	}
	log.Printf("Near preceding node id: %v, result: %v\n", id, node.Info)
	return node.Info
}

// Starts the node by either calling create or join
func Begin(ownIp string, ownPort, securePort, fingerTableCount, successorsCount int, initNewRing bool, joinIp *string, joinPort *int, additionalId *big.Int) error {
	log.Printf("node started %v:%v with securePort port: %v", ownIp, ownPort, securePort)
	// Predecessor is sets to nil
	err := InitializeNode(ownIp, ownPort, securePort, fingerTableCount, successorsCount, additionalId)
	if err != nil {
		return err
	}
	if initNewRing {
		create_ring()
		return nil
	}
	if joinIp == nil || joinPort == nil {
		return errors.New("if createNewRing is set to false, join IP address and join port are required")
	}
	temp_Id := Get().Info.Id
	return Join_ring(*joinIp, *joinPort, &temp_Id, fingerTableCount)
}

// New chord ring is creating
func create_ring() {
	UpdateSuccessor(Get().Info)
	UpdateFingerTable(Get().Info)
}

// Node joining the existing ring
func Join_ring(joinIp string, joinPort int, nodeId *big.Int, maxSteps int) error {
	//Dummy values are required for the method to function, but they have no effect on the logic because the start value is only utilized for its address and not as an identifier.
	joinHash := big.NewInt(-1)
	securePort := -1

	successor, err := FindNode(*nodeId, NodeDetails{OwnIp: joinIp, OwnPort: joinPort, SecurePort: securePort, Id: *joinHash}, maxSteps)
	if err != nil {
		return err
	}
	UpdateSuccessor(*successor)
	UpdateFingerTable(*successor)
	return nil
}

func Stabilize() {
	var nD *NodeDetails
	successorIndex := -1
	node := Get()
	// Use the first living successor's predecessor as the new successor.
	for position, item := range node.Successors {
		var err error
		// Error occurs exclusively when establishing a connection is not possible.
		nD, err = Predecessor(FetchChordAddress(item))
		log.Printf("predecessor is %v, err: %v, index: %v", nD, err, position)
		if err == nil {
			successorIndex = position
			break
		}
	}
	// If the successor does not point to a predecessor, then nD might be nil, hence checking for that is necessary.
	if nD != nil && WithIn(&node.Info.Id, &nD.Id, &node.Successors[successorIndex].Id, false) {
		UpdateSuccessor(*nD)
	} else if nD != nil {
		// new successor is made the first active successor from the previous list.
		UpdateSuccessor(node.Successors[successorIndex])
	} else {
		// If there are no successors, refer to yourself
		UpdateSuccessor(node.Info)
	}
	if len(nodeInstance.Successors) > 0 {
		// new successor is notified that we are their new predecessor
		err := RpcNotify(FetchChordAddress(Successor()), node.Info)
		if err != nil {
			log.Printf("Notification error with successor %v: %v", Successor(), err.Error())
		}

		successors, err := Successors(FetchChordAddress(Successor()))
		if err == nil {
			AddSuccessors(successors)
		} else {
			log.Printf("Error fetching successors from %v: %v", Successor(), err.Error())
		}
	}
	log.Printf("Successor list updated with new successor %v, new length: %v", node.Successors[0], len(node.Successors))
}

func Notify(node NodeDetails) {
	n := Get()
	Msg := fmt.Sprintf("Invoked by: %v with ID: %v, Current predecessor: %v", node.OwnIp, node.Id.String(), n.Predecessor)
	// To avoid getting stucked, make sure that it doesn't have itself as predecessor
	if n.Predecessor == nil || n.Predecessor.Id.Cmp(&n.Info.Id) == 0 ||
		WithIn(&n.Predecessor.Id, &node.Id, &n.Info.Id, false) {
		SetPredecessor(&node)
		Msg += ". updated Predecessor."
	} else {
		Msg += ". not updated Predecessor."
	}
	log.Printf("%v\n", Msg)
}

func FixFingers() {
	index := IncrementFollowFinger()
	log.Printf("next: %v", index)
	nI := Get()
	idToFix := *Jump(nI.Info.Id, index)
	node, err := FindNode(idToFix, nI.Info, 32)
	if err != nil {
		log.Printf("Error occured while setting finger table index %v to Id %v+2^(%v)=%v. err: %v\n", index, nI.Info.Id, index, idToFix, err.Error())
		return
	}

	if index >= nodeInstance.FingerTableSize || index > len(nodeInstance.FingerTable) {
		log.Printf("Index beyond size, element at position" + fmt.Sprintf("%v", index-1) + "missing")

	}
	if index < len(nodeInstance.FingerTable) {
		nodeInstance.FingerTable[index] = *node
		return
	}
	nodeInstance.FingerTable = append(nodeInstance.FingerTable, *node)
}

func CheckPredecessor() {
	node := Get()
	if node.Predecessor != nil && !IsAlive(FetchChordAddress(*node.Predecessor)) {
		SetPredecessor(nil)
		log.Printf(" Predecessor set to nil due to unresponsiveness from previous predecessor  %v\n", node.Predecessor)
	}
}

// translates the hexstring into a large int type identifier.
func HexStringToBytes(hexString string) (*big.Int, error) {
	bytes, err := hex.DecodeString(hexString)
	if err != nil {
		return nil, err
	}
	return new(big.Int).SetBytes(bytes), nil
}

const keyLength = RING_SIZE_BITS

var two = big.NewInt(2)
var hashMod = new(big.Int).Exp(two, big.NewInt(keyLength), nil)

// Hash is created from elt string and retured it as pointer to bing int
func GenerateHash(elt string) *big.Int {
	hash := sha1.New()
	hash.Write([]byte(elt))
	return new(big.Int).SetBytes(hash.Sum(nil))
}

// Identifier is returned based on the finger table entry number and starting address
func Jump(nodeIdentifier big.Int, fingerentry int) *big.Int {
	fingerentryBig := big.NewInt(int64(fingerentry))
	jump := new(big.Int).Exp(two, fingerentryBig, nil)
	sum := new(big.Int).Add(&nodeIdentifier, jump)

	return new(big.Int).Mod(sum, hashMod)
}

// checking if elt is with in (start, end)
func WithIn(start, elt, end *big.Int, inclusive bool) bool {
	if end.Cmp(start) > 0 {
		return (start.Cmp(elt) < 0 && elt.Cmp(end) < 0) || (inclusive && elt.Cmp(end) == 0)
	} else {
		return start.Cmp(elt) < 0 || elt.Cmp(end) < 0 || (inclusive && elt.Cmp(end) == 0)
	}
}

var lock = new(sync.RWMutex)

func GetRWLock(write bool) {
	if write {
		lock.Lock()
		return
	}
	lock.RLock()
}

func ReleaseRWLock(write bool) {
	if write {
		lock.Unlock()
		return
	}
	lock.RUnlock()
}

func InitializeNodeFileSystem(node_id string) error {
	folder := FetchFileLocation(node_id)
	err := os.MkdirAll(folder, DIR_PRIVILEGES)
	if err != nil {
		return err
	}
	return nil
}

func FilesList(node_id string) ([]string, error) {
	loc, err := os.ReadDir(FetchFileLocation(node_id))
	if err != nil {
		log.Printf("[files.ListFiles] could not read dir: %v\n", err)
		return nil, err
	}
	files := []string{}
	for _, file := range loc {
		files = append(files, file.Name())
	}
	return files, nil
}

func FileRead(fileLoc string) ([]byte, error) {
	file, err := os.ReadFile(fileLoc)
	return file, err
}

func ReadNodeFiles(node_Id string, fileLocs []string) map[string]*[]byte {
	files := make(map[string]*[]byte)
	for _, fileLoc := range fileLocs {
		data, err := os.ReadFile(FetchFilePath(node_Id, fileLoc))
		if err == nil {
			files[fileLoc] = &data
		}
	}
	return files
}

func FetchFileLocation(nodeId string) string {
	return filepath.Join(ENCRYPTED_RESOURCES_FOLDER, nodeId)
}

func FetchFilePath(key, nodeKey string) string {
	return filepath.Join(FetchFileLocation(nodeKey), key)
}

func WriteNodeFile(key, node_Id string, data []byte) error {
	directory := FetchFileLocation(node_Id)
	err := os.MkdirAll(directory, DIR_PRIVILEGES)
	if err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(directory, key), data, FILE_PRIVILEGES)
}

func WriteNodeFiles(node_Id string, files map[string]*[]byte) []error {
	folder := FetchFileLocation(node_Id)
	err := os.MkdirAll(folder, DIR_PRIVILEGES)
	if err != nil {
		return []error{err}
	}
	Writeerrs := []error{}
	for key, data := range files {
		Writeerr := os.WriteFile(FetchFilePath(key, node_Id), *data, FILE_PRIVILEGES)
		if Writeerr != nil {
			Writeerrs = append(Writeerrs, Writeerr)
		}
	}
	return Writeerrs
}

func AppendToFile(key, node_Id string, data []byte) (int, error) {
	file, err := os.OpenFile(FetchFilePath(key, node_Id), os.O_APPEND|os.O_WRONLY, FILE_PRIVILEGES)
	if err != nil {
		return 0, err
	}
	defer file.Close()

	num, err := file.Write(data)
	if err != nil {
		return num, err
	}

	return num, nil
}

func DeleteFile(key, node_Id string) {
	os.Remove(FetchFilePath(key, node_Id))
}
